ui = 'cgui'.use

(events, app) = (Channels.make, Channels.make)

ui.run\gui(events, app).unwrap

red = '0xff0000ff'.as\n
blue = '0x0000ffff'.as\n
green = '0x00ff00ff'.as\n

CELL_SIZE = 10
MOVE_INTERVAL = 50
FOOD_INTERVAL = 100
WIDTH = 800
HEIGHT = 800
MOVE_DIST = CELL_SIZE

model = {
  gameover: false:
  eaten: 0
  snake: [{ x: 200 y: 200 facing: right:}]
  time: 0
  foods: []
}

move: .defcase {
  left:  model => model.put_by(x: x => x - MOVE_DIST)
  right: model => model.put_by(x: x => x + MOVE_DIST)
  up:    model => model.put_by(y: y => y - MOVE_DIST)
  down:  model => model.put_by(y: y => y + MOVE_DIST)
}

Cells = snake\cell: .defclass (
  x: y: facing:
  default:
  {
    move:  () => self.facing.move self
    render\snake: () => [
      rect:
      { x: self.x, y: self.y, w: CELL_SIZE, h: CELL_SIZE, color: red }
    ]
    within_n: (other, n) => do
      x = (other.x - self.x)
      y = (other.y - self.y)
      dist = (x * x) + (y * y)
      dist < (n * n)
    end
  })

[Cells] .defmodule {
  behind: cell => cell.facing.behind(cell)
}

behind: .defcase {
  up: cell => cell.put(y: cell.y + CELL_SIZE .* 2)
  down: cell => cell.put(y: cell.y - CELL_SIZE .* 2)
  left: cell => cell.put(x: cell.x - CELL_SIZE .* 2)
  right:  cell => cell.put(x: cell.x + CELL_SIZE .* 2)
}

Foods = snake\food: .defclass (
  x: y:
  default:
  {
    render\food: () => [
      rect:
      { x: self.x, y: self.y, w: CELL_SIZE, h: CELL_SIZE, color: green }
    ]
    within_n: (other, n) => do
      x = (other.x - self.x)
      y = (other.y - self.y)
      dist = (x * x) + (y * y)
      dist < (n * n)
    end
  })

[model?].defmodule {
  head: () => self.snake.at 0 .unwrap
  body: () => self.snake.slice(1, self.snake.len)

  should_spawn_food: () => do
    self.time % FOOD_INTERVAL == 0
  end

  spawn_food: () => do
    size = CELL_SIZE / 20
    randomx = Numbers.int\between(0, WIDTH / size)
    randomy = Numbers.int\between(0, HEIGHT / size)

    foods = self.foods.push(Foods.t.make(randomx * size, randomy * size))
    
    self.put(foods: foods)
  end

  move_snake: () => do
    old_snake = self.snake

    self.put(
      snake:
      old_snake
        .map(cell i) => do
          (ok, leader) = old_snake.at(i - 1)

          ok
            .then(() => leader)
            .else(() => cell.move)
        end)
  end

  append_tail: () => do
    snake = self.snake
    tail = snake.at(snake.len - 1).unwrap
    snake = snake.push(Cells.behind(tail))

    self.put(snake: snake)
  end
}

handle\keydown: .defcase {
  h: (ev model) => model.put_via(snake: 0 facing: left:)
  j: (ev model) => model.put_via(snake: 0 facing: down:)
  k: (ev model) => model.put_via(snake: 0 facing: up:)
  l: (ev model) => model.put_via(snake: 0 facing: right:)

  Messages.t
  (ev model) => do
    'Unhandled key: $\n'.printf(self)
    model
  end
}

handle\keyup: .defcase {
  Messages.t
  (ev model) => model
}

handle\key: .defcase {
  true: (msg ev model) => msg.handle\keydown(ev model)
  false: (msg ev model) => msg.handle\keyup(ev model)
}

handle\type: .defcase {
  tick:  (ev model) => do
    # Tick time
    model = model.put_via_by(time: x => x++)

    model
   		.when(
        model.should_spawn_food
        m => m.spawn_food)
   		.when(
        model.time % MOVE_INTERVAL == 0
        m => m.move_snake)
  end
  mouse: (ev model) => do
    ev.println
    model
  end
  key:   (ev model) => do
    keymsg = ev.at 0 .unwrap
    down = ev.at 2 .unwrap
    down.handle\key(keymsg ev model)
  end
}

behaviors = {
  behavior\eat_food: (model) => do
    head = model.head

    non_colliding_foods = model
      .foods
      .filter(food => food.within_n(head, 10)!)

    ate = non_colliding_foods.len < model.foods.len

    model
      .when(ate model => model.put(foods: non_colliding_foods))
      .when(ate model => model.put(eaten: model.eaten + model.foods.len - non_colliding_foods.len))
      .when(ate model => model.append_tail)
  end
  behavior\collide_self: (model) => do
    head = model.head

    colliding_cells = model
      .body
      .filter(cell => cell.within_n(head, 10))

    collided = colliding_cells.len > 0

    model
      .when(collided model => model.put(gameover: true:))
  end
  behavior\collide_wall: (model) => do
    head = model.head

    oob_left = model.head.x < 0
    oob_right = model.head.x > WIDTH
    oob_up = model.head.y < 0
    oob_down = model.head.y > HEIGHT

    model
      .when(
        oob_left | oob_right | oob_up | oob_down
        model => model.put(gameover: true:))
  end
}

behavior = [behaviors*].transduce(x => x, (acc x) => acc |> x)

[model?] .defmodule {
  # Reduce events into new models
  controller: (type, ev*) => do
    res = type
      .handle\type(ev, self)
      .behavior

    res
  end

  behaviors**

  # Apply behaviors that should change model state
  behavior: () => behavior.(self)
}

view: .def (
  model?
  () => do
    model = self

    self
      .gameover
      .then(() => [
        [box:
          { 
            radius: 10
            border: { color: green width: 5 }
          }
          [
            [text: { content: "Gameover! Score: $".sprintf(model.eaten) size: 128 }]
          ]
        ]
      ])
      .else(() => [
          [box:
            {
              radius: 10
              border: { color: green width: 5 }
            }
            [
              [text: { content: "Score: $".sprintf(model.eaten) size: 32 }]
            ]
          ]

          (model.snake.map model => model.render\snake)*
          (model.foods.map model => model.render\food)*
        ])
  end)

events
  .pipe(
    app,
    Streams.reduce(model (app, args*) => app.controller(args*))
    |> Streams.map(app => app.view)
  )
