'chttp'.use
Socket = IO.Sockets

cert = IO.Files.make("MyCertificate.crt" "r").unwrap
pkey = IO.Files.make("MyKey.key" "r").unwrap

cert = cert.read(cert.len).unwrap
pkey = pkey.read(pkey.len).unwrap

server_fiber = Fibers.make () => do

  server = Socket.make tcp\tls: .unwrap

  server
    .bind("::1" 443 cert pkey)
    .unwrap

  server
    .listen 5
    .unwrap

  'SERVER LISTENING ON ::1 443'.println

  Fibers.make () => do
    client = server
      .accept
      .unwrap

    'Accepted client: $\n'.sprintf(client).println

    req = client.until('\n'.to\b).unwrap

    'CLIENT SENT: "$"\n'.sprintf(req.as\s.unwrap).println

    client.write(req)
    client.write('\0'.to\b)
  end
end

server_fiber.await

req = 'GET / HTTP/1.0\r\nHost:www.google.com\r\n\r\n'

sock = Socket
  .make tcp\tls:
  .unwrap

sock
  .connect("::1" 443 cert)
  .unwrap

sock
  .write(req.to\b)
  .unwrap

data = sock.until('\0'.to\b).unwrap.as\s.unwrap

#sock = Socket
#  .make tcp:
#  .unwrap
#
#sock
#  .connect("www.google.com" 80)
#  .unwrap
#
#sock
#  .write(req.to\b)
#  .unwrap

# In practice, this reads until the socket is closed.
#data = sock.until('\0'.to\b).unwrap.as\s.unwrap

http_res = data
  .as\http
  .unwrap

'STATUS: $\nHEADERS:\n$\nBODY:\n$'
  .sprintf(
    http_res.http\status
    http_res.http\headers.join(
      ""
      Streams.map((value field) => do
        '$: $'.sprintf(field value)
      end)
      |> Streams.interpose '\n')
    http_res.http\body)
  .println
