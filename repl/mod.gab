'data.json'.use
'cgab'.use
Ranges = 'ranges'.use
xf = 'transducers'.use
Terminal = 'os.terminal'.use

(term, events) = (Terminal.make, Channels.make)

(server) = Channels.make

event\quit?:.def!(
  Records.t,
  () => self.ch == 'q')

# Fiber for polling terminal events and pushing them
# into a channel for handling. Transducer terminates
# the stream on the quit event.
Fibers.make () => do
  term.pipe(
    events
    xf.take_until event\quit?:)

# Close all channels at this point.
  events.close!
  server.close!
end

EvalCmd = Shapes.make(eval: source:)

cmd\handle:.defcase! {
  EvalCmd (state) => do
    (status, res[], env) = self.source.gab\eval(state.env)

    server <! {
      status: status,
      res: res,
      env: env,
    }

    state.env env
  end
}

REPLServer = Shapes.make(env:)

make:.def!(
  REPLServer:
  () => REPLServer.make(nil:))

run:.def!(
  REPLServer:
  ()
    => Fibers.make ()
      => server.reduce(
        REPLServer:.make,
        (state, cmd)
          => cmd.cmd\handle state))

REPLServer:.run

REPLClient = Shapes.make(input: history:)

make:.def!(
  REPLClient:,
  () => REPLClient.make("" []))

event\ctrl\key\handle:.def! (state) => state

event\ctrl\key\handle:.defcase! {
  backspace: (state, event) => do
    input = state.input.slice(0, state.input.len - 1)
    state.input input
  end
  enter: (state, event) => do
    server <! EvalCmd.make(nil: state.input)

    (ok, res) = server >!

    history_elem = { source: state.input, result: res }

    ok
      .and state.history(state.history.push history_elem)
      .or state
      .input ""
  end
}

event\key\handle:.defcase! {
  ctrl: (state, event) => event.key.event\ctrl\key\handle(state event),
  key: (state, event) => do
    input = state.input + event.ch
    state.input input
  end
}

event\handle:.defcase! {
  key: (state, event) => event.mod.event\key\handle(state event)
}

box_chars = {
  h: "─"
  v: "│"
  bl: "╰"
  br: "╯"
  tl: "╭"
  tr: "╮"
}

doprintline:.defcase! {
  horizontal: (x y dx char)
    => x .-> (x + dx) .each i
      => term.cell\set(i y char)
  vertical: (x y dy char)
    => y .-> (y + dy) .each i
      => term.cell\set(x i char)
}

printline = (x y opts{})
  => opts.axis.doprintline(x y opts.dist, opts.char)

printbox = (x y w h) => do
  term.cell\set(x y box_chars.tl)
  term.cell\set(x + w y box_chars.tr)
  term.cell\set(x y + h box_chars.bl)
  term.cell\set(x + w y + h box_chars.br)

  printline.(
    x + 1
    y
    char: box_chars.h
    axis: horizontal:
    dist: w - 2)

  printline.(
    x
    y + 1
    char: box_chars.v
    axis: vertical:
    dist: h - 2)

  printline.(
    x + 1
    y + h
    char: box_chars.h
    axis: horizontal:
    dist: w - 2)

  printline.(
    x + w
    y + 1
    char: box_chars.v
    axis: vertical:
    dist: h - 2)
end

events
  .reduce(
    REPLClient:.make, # Initial state
    (state event) => do
      term.clear!

      state = event.type.event\handle(state, event)

      term.print(0, 0, event.json\encode)
      term.print(0, 1, state.json\encode)

      (w h) = (term.width, term.height)

      state.history.each (h, i) => do
        source_line = "$: $".sprintf(i, h.source)
        term.print(0, 3 + (i * 2), source_line)

        result_line = "=> $ $".sprintf(h.result.status, h.result.res.map strings\into: .join)
        term.print(0, 4 + (i * 2), result_line)
      end

      printbox.(0 h - 3 w - 2 2)
      input_line = " > $".sprintf(state.input)
      term.print(1, h - 2, input_line)

      term.render!

      state
    end)
