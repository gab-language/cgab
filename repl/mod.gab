'data.json'.use
'cgab'.use
Ranges = 'ranges'.use
xf = 'transducers'.use
Terminal = 'os.terminal'.use

(term, events) = (Terminal.make, Channels.make)

(servin, servout) = (Channels.make, Channels.make)

event\quit?:.def!(
  Records.t,
  () => self.ch == 'q')

# Fiber for polling terminal events and pushing them
# into a channel for handling. Transducer terminates
# the stream on the quit event.
Fibers.make () => do
  term.pipe(
    events
    xf.take_until event\quit?:)

# Close all channels at this point.
  events.close!
  servin.close!
  servout.close!
end

EvalCmd = Shapes.make(eval: source:)

cmd\handle:.defcase! {
  EvalCmd () => do
    (res[]) = self.source.gab\eval
    servout <! res
  end
}

# Fiber for "server" half of repl
Fibers.make () => servin.each cmd\handle:

REPL = Shapes.make(input: history:)

make:.def!(
  REPL:,
  () => REPL.make("" []))

event\ctrl\key\handle:.def! (state) => state

event\ctrl\key\handle:.defcase! {
  backspace: (state, event) => do
    input = state.input.slice(0, state.input.len - 1)
    state.input input
  end
  enter: (state, event) => do
    servin <! EvalCmd.make(nil: state.input)

    (ok, res) = servout >!

    history_elem = { source: state.input, result: res }

    state = ok
      .and state.history(state.history.push history_elem)
      .or state

    state.input ""
  end
}

event\key\handle:.defcase! {
  ctrl: (state, event) => event.key.event\ctrl\key\handle(state event),
  key: (state, event) => do
    input = state.input + event.ch
    state.input input
  end
}

event\handle:.defcase! {
  key: (state, event) => event.mod.event\key\handle(state event)
}

box_chars = {
  h: "─"
  v: "│"
  bl: "╰"
  br: "╯"
  tl: "╭"
  tr: "╮"
}

doprintline:.defcase! {
  horizontal: (x y dx char)
    => x .-> (x + dx) .each i
      => term.cell\set(i y char)
  vertical: (x y dy char)
    => y .-> (y + dy) .each i
      => term.cell\set(x i char)
}

printline = (x y opts{})
  => opts.axis.doprintline(x y opts.dist, opts.char)

printbox = (x y w h) => do
  term.cell\set(x y box_chars.tl)
  term.cell\set(x + w y box_chars.tr)
  term.cell\set(x y + h box_chars.bl)
  term.cell\set(x + w y + h box_chars.br)

  printline.(
    x + 1
    y
    char: box_chars.h
    axis: horizontal:
    dist: w - 2)

  printline.(
    x
    y + 1
    char: box_chars.v
    axis: vertical:
    dist: h - 2)

  printline.(
    x + 1
    y + h
    char: box_chars.h
    axis: horizontal:
    dist: w - 2)

  printline.(
    x + w
    y + 1
    char: box_chars.v
    axis: vertical:
    dist: h - 2)
end

events
  .reduce(
    REPL:.make, # Initial state
    (state event) => do
      term.clear!

      state = event.type.event\handle(state, event)

      term.print(0, 0, event.json\encode)
      term.print(0, 1, state.json\encode)

      (w h) = (term.width, term.height)

      state.history.each (h, i) => do
        term.print(0, 3 + (i * 2), h.source)
        term.print(0, 4 + (i * 2), h.result.json\encode)
      end

      printbox.(0 h - 3 w - 2 2)
      term.print(1, h - 2, state.input)

      term.render!

      state
    end)
