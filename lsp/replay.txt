Content-Length: 3913

{"method":"initialize","jsonrpc":"2.0","id":1,"params":{"rootPath":null,"trace":"off","rootUri":null,"clientInfo":{"version":"0.11.0","name":"Neovim"},"workDoneToken":"1","capabilities":{"general":{"positionEncodings":["utf-8","utf-16","utf-32"]},"window":{"workDoneProgress":true,"showMessage":{"messageActionItem":{"additionalPropertiesSupport":true}},"showDocument":{"support":true}},"workspace":{"workspaceEdit":{"resourceOperations":["rename","create","delete"]},"configuration":true,"didChangeConfiguration":{"dynamicRegistration":false},"applyEdit":true,"semanticTokens":{"refreshSupport":true},"workspaceFolders":true,"inlayHint":{"refreshSupport":true},"symbol":{"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"dynamicRegistration":false},"didChangeWatchedFiles":{"relativePatternSupport":true,"dynamicRegistration":false}},"textDocument":{"completion":{"completionList":{"itemDefaults":["editRange","insertTextFormat","insertTextMode","data"]},"completionItemKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]},"completionItem":{"documentationFormat":["markdown","plaintext"],"resolveSupport":{"properties":["additionalTextEdits","command"]},"deprecatedSupport":true,"preselectSupport":false,"commitCharactersSupport":false,"snippetSupport":true,"tagSupport":{"valueSet":[1]}},"contextSupport":true,"dynamicRegistration":false},"definition":{"linkSupport":true,"dynamicRegistration":true},"synchronization":{"didSave":true,"willSaveWaitUntil":true,"willSave":true,"dynamicRegistration":false},"semanticTokens":{"augmentsSyntaxTokens":true,"serverCancelSupport":false,"multilineTokenSupport":false,"overlappingTokenSupport":true,"formats":["relative"],"tokenModifiers":["declaration","definition","readonly","static","deprecated","abstract","async","modification","documentation","defaultLibrary"],"tokenTypes":["namespace","type","class","enum","interface","struct","typeParameter","parameter","variable","property","enumMember","event","function","method","macro","keyword","modifier","comment","string","number","regexp","operator","decorator"],"requests":{"full":{"delta":true},"range":false},"dynamicRegistration":false},"diagnostic":{"dynamicRegistration":false},"inlayHint":{"resolveSupport":{"properties":["textEdits","tooltip","location","command"]},"dynamicRegistration":true},"callHierarchy":{"dynamicRegistration":false},"rename":{"dynamicRegistration":true,"prepareSupport":true},"formatting":{"dynamicRegistration":true},"hover":{"contentFormat":["markdown","plaintext"],"dynamicRegistration":true},"documentSymbol":{"hierarchicalDocumentSymbolSupport":true,"symbolKind":{"valueSet":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]},"dynamicRegistration":false},"references":{"dynamicRegistration":false},"signatureHelp":{"signatureInformation":{"parameterInformation":{"labelOffsetSupport":true},"activeParameterSupport":true,"documentationFormat":["markdown","plaintext"]},"dynamicRegistration":false},"publishDiagnostics":{"dataSupport":true,"relatedInformation":true,"tagSupport":{"valueSet":[1,2]}},"rangeFormatting":{"dynamicRegistration":true,"rangesSupport":true},"documentHighlight":{"dynamicRegistration":false},"foldingRange":{"lineFoldingOnly":true,"foldingRange":{"collapsedText":true},"dynamicRegistration":false},"typeDefinition":{"linkSupport":true},"implementation":{"linkSupport":true},"codeLens":{"resolveSupport":{"properties":["command"]},"dynamicRegistration":false},"codeAction":{"dataSupport":true,"isPreferredSupport":true,"codeActionLiteralSupport":{"codeActionKind":{"valueSet":["","quickfix","refactor","refactor.extract","refactor.inline","refactor.rewrite","source","source.organizeImports"]}},"resolveSupport":{"properties":["edit","command"]},"dynamicRegistration":true},"declaration":{"linkSupport":true}}},"workspaceFolders":null,"processId":20462}}Content-Length: 52

{"jsonrpc":"2.0","method":"initialized","params":{}}Content-Length: 5756

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/tr/repos/cgab/repl/mod.gab","languageId":"gab","version":0,"text":"'cgab'.use\n'ranges'.use\nxf = 'transducers'.use\nTerminal = 'os.terminal'.use\n\nterm = Terminal.make\n\n(events, server) = (Channels.make, Channels.make)\n\nevent\\quit:.def(\n  Records.t,\n  () => self.ch == 'q')\n\n# Fiber for polling terminal events and pushing them\n# into a channel for handling. Transducer terminates\n# the stream on the quit event.\nMain = Fibers.make () => do\n  term.pipe(\n    events\n    xf.take_until event\\quit?:)\n\n# Close all channels at this point.\n  events.close!\n  server.close!\nend\n\nHistoryElement = Shapes.make(source: result:)\n\nto\\s:.defcase {\n  Shapes.make(status: fiber:) () => do\n   \"=> $ $\".sprintf(self.status, self.fiber)\n  end\n  Shapes.make(status: res: env:) () => do\n    \"=> $ $\".sprintf(self.status, self.res.map to\\s: .join(xf.interpose \" \"))\n  end\n}\n\nEvalCmd = Shapes.make(eval:)\nEnvCmd = Shapes.make(env:)\n\ntick\\history_element\\result:.defcase {\n  Shapes.make(status: fiber:) (he) => do\n    result = he.result\n    fib = result.fiber\n\n    fib\n      .then done?:\n      .then(() => do\n        (status, res[], env) = fib.await!\n\n        status\n          .ok?\n          .then(() => server <! EnvCmd.make(env))\n\n        he.result {\n          status: status\n          res: res\n          env: env\n        }\n      end)\n      .or he\n  end\n  Shapes.make(status: res: env:) (he) => he\n}\n\ntick\\history_element:.def(\n  HistoryElement\n  () => self.result.tick\\history_element\\result self)\n\ncmd\\handle:.defcase {\n  EvalCmd (state) => do\n    (ok, fib) = self.eval.gab\\eval(state.env)\n\n    server <! { status: ok, fiber: fib }\n\n    state\n  end\n  EnvCmd (state) => do\n    state.env(self.env)\n  end\n}\n\nREPLServer = Shapes.make(env:)\n\nmake:.def(\n  REPLServer:\n  () => REPLServer.make(nil:))\n\nrun:.def(\n  REPLServer:\n  ()\n    => Fibers.make ()\n      => server.reduce(\n        REPLServer:.make,\n        (state, cmd)\n          => cmd.cmd\\handle state))\n\nServer = REPLServer:.run\n\nREPLClient = Shapes.make(input: history_index: history:)\n\nmake:.def(\n  REPLClient:,\n  () => REPLClient.make(\"\" 0 []))\n\nevent\\ctrl\\key\\handle:.def (state) => state\n\nevent\\ctrl\\key\\handle:.defcase {\n  backspace: (state, event) => do\n    input = state.input.slice(0, state.input.len - 1)\n    state.input input\n  end\n  enter: (state, event) => do\n    server <! EvalCmd.make(state.input)\n\n    (ok, res) = server >!\n\n    history_elem = HistoryElement.make(state.input, res)\n\n    state = ok\n      .and state.history(state.history.push history_elem)\n      .or state\n      .input \"\"\n\n    state.history_index(state.history.len)\n  end\n}\n\nevent\\key\\key\\handle:.defcase {\n  arrow\\down: (state, event) => do\n    state = state.history_index(state.history_index ++)\n    (ok, hist) = state.history.at(state.history_index)\n\n    ok\n      .then(() => state.input(hist.source))\n      .else(() => state.input \"\")\n  end\n  arrow\\up: (state, event) => do\n    state = state.history_index(state.history_index --)\n    (ok, hist) = state.history.at(state.history_index)\n\n    ok\n      .then(() => state.input(hist.source))\n      .else(() => state.input \"\")\n  end\n}\n\nevent\\key\\key\\handle:.def (state event) =>  do\n  input = state.input + event.ch\n  state.input input\nend\n\nevent\\key\\handle:.defcase {\n  ctrl: (state, event) => event.key.event\\ctrl\\key\\handle(state event),\n  key: (state, event) => event.key.event\\key\\key\\handle(state event)\n}\n\nevent\\handle:.defcase {\n  key: (state, event) => event.mod.event\\key\\handle(state event)\n  tick: (state) => do\n    state.history(state.history.map tick\\history_element:)\n  end\n}\n\nbox_chars = {\n  h: \"─\"\n  v: \"│\"\n  bl: \"╰\"\n  br: \"╯\"\n  tl: \"╭\"\n  tr: \"╮\"\n}\n\ndoprintline:.defcase {\n  horizontal: (x y dx char)\n    => x .-> (x + dx) .each i\n      => term.cell\\set(i y char)\n  vertical: (x y dy char)\n    => y .-> (y + dy) .each i\n      => term.cell\\set(x i char)\n}\n\nprintline = (x y opts{})\n  => opts.axis.doprintline(x y opts.dist, opts.char)\n\nprintbox = (x y w h) => do\n  term.cell\\set(x y box_chars.tl)\n  term.cell\\set(x + w y box_chars.tr)\n  term.cell\\set(x y + h box_chars.bl)\n  term.cell\\set(x + w y + h box_chars.br)\n\n  printline.(\n    x + 1\n    y\n    char: box_chars.h\n    axis: horizontal:\n    dist: w - 2)\n\n  printline.(\n    x\n    y + 1\n    char: box_chars.v\n    axis: vertical:\n    dist: h - 2)\n\n  printline.(\n    x + 1\n    y + h\n    char: box_chars.h\n    axis: horizontal:\n    dist: w - 2)\n\n  printline.(\n    x + w\n    y + 1\n    char: box_chars.v\n    axis: vertical:\n    dist: h - 2)\nend\n\nTicker = Fibers.make () => do\n  events <! { type: tick: }\n\n  Fibers.sleep!(100000000)\n\n  events.closed?.else self\nend\n\nClient = Fibers.make() \n  => events\n  .reduce(\n    REPLClient:.make, # Initial state\n    (state event) => do\n      term.clear!\n\n      #term.print!(0, 0, \"$\".sprintf event)\n\n      state = event.type.event\\handle(state, event)\n\n      (w h) = (term.width, term.height)\n\n      state.history.each (h, i) => do\n        source_line = \"$: $\".sprintf(i, h.source)\n        term.print!(0, 3 + (i * 2), source_line)\n\n        result_line = h.result.to\\s\n        term.print!(0, 4 + (i * 2), result_line)\n      end\n\n      printbox.(0 h - 3 w - 2 2)\n      input_line = \" > $\".sprintf(state.input)\n      term.print!(1, h - 2, input_line)\n\n      term.render!\n\n      state\n    end)\n\n[Main Server Client Ticker]\n  .map await!:\n  .map unwrap!:\n"}}}Content-Length: 5734

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"text":"'cgab'.use\n'ranges'.use\nxf = 'transducers'.use\nTerminal = 'os.terminal'.use\n\nterm = Terminal.make\n\na + 1\n\n(events, server) = (Channels.make, Channels.make)\n\nevent\\quit:.def(\n  Records.t,\n  () => self.ch == 'q')\n\n# Fiber for polling terminal events and pushing them\n# into a channel for handling. Transducer terminates\n# the stream on the quit event.\nMain = Fibers.make () => do\n  term.pipe(\n    events\n    xf.take_until event\\quit?:)\n\n# Close all channels at this point.\n  events.close!\n  server.close!\nend\n\nHistoryElement = Shapes.make(source: result:)\n\nto\\s:.defcase {\n  Shapes.make(status: fiber:) () => do\n   \"=> $ $\".sprintf(self.status, self.fiber)\n  end\n  Shapes.make(status: res: env:) () => do\n    \"=> $ $\".sprintf(self.status, self.res.map to\\s: .join(xf.interpose \" \"))\n  end\n}\n\nEvalCmd = Shapes.make(eval:)\nEnvCmd = Shapes.make(env:)\n\ntick\\history_element\\result:.defcase {\n  Shapes.make(status: fiber:) (he) => do\n    result = he.result\n    fib = result.fiber\n\n    fib\n      .then done?:\n      .then(() => do\n        (status, res[], env) = fib.await!\n\n        status\n          .ok?\n          .then(() => server <! EnvCmd.make(env))\n\n        he.result {\n          status: status\n          res: res\n          env: env\n        }\n      end)\n      .or he\n  end\n  Shapes.make(status: res: env:) (he) => he\n}\n\ntick\\history_element:.def(\n  HistoryElement\n  () => self.result.tick\\history_element\\result self)\n\ncmd\\handle:.defcase {\n  EvalCmd (state) => do\n    (ok, fib) = self.eval.gab\\eval(state.env)\n\n    server <! { status: ok, fiber: fib }\n\n    state\n  end\n  EnvCmd (state) => do\n    state.env(self.env)\n  end\n}\n\nREPLServer = Shapes.make(env:)\n\nmake:.def(\n  REPLServer:\n  () => REPLServer.make(nil:))\n\nrun:.def(\n  REPLServer:\n  ()\n    => Fibers.make ()\n      => server.reduce(\n        REPLServer:.make,\n        (state, cmd)\n          => cmd.cmd\\handle state))\n\nServer = REPLServer:.run\n\nREPLClient = Shapes.make(input: history_index: history:)\n\nmake:.def(\n  REPLClient:,\n  () => REPLClient.make(\"\" 0 []))\n\nevent\\ctrl\\key\\handle:.def (state) => state\n\nevent\\ctrl\\key\\handle:.defcase {\n  backspace: (state, event) => do\n    input = state.input.slice(0, state.input.len - 1)\n    state.input input\n  end\n  enter: (state, event) => do\n    server <! EvalCmd.make(state.input)\n\n    (ok, res) = server >!\n\n    history_elem = HistoryElement.make(state.input, res)\n\n    state = ok\n      .and state.history(state.history.push history_elem)\n      .or state\n      .input \"\"\n\n    state.history_index(state.history.len)\n  end\n}\n\nevent\\key\\key\\handle:.defcase {\n  arrow\\down: (state, event) => do\n    state = state.history_index(state.history_index ++)\n    (ok, hist) = state.history.at(state.history_index)\n\n    ok\n      .then(() => state.input(hist.source))\n      .else(() => state.input \"\")\n  end\n  arrow\\up: (state, event) => do\n    state = state.history_index(state.history_index --)\n    (ok, hist) = state.history.at(state.history_index)\n\n    ok\n      .then(() => state.input(hist.source))\n      .else(() => state.input \"\")\n  end\n}\n\nevent\\key\\key\\handle:.def (state event) =>  do\n  input = state.input + event.ch\n  state.input input\nend\n\nevent\\key\\handle:.defcase {\n  ctrl: (state, event) => event.key.event\\ctrl\\key\\handle(state event),\n  key: (state, event) => event.key.event\\key\\key\\handle(state event)\n}\n\nevent\\handle:.defcase {\n  key: (state, event) => event.mod.event\\key\\handle(state event)\n  tick: (state) => do\n    state.history(state.history.map tick\\history_element:)\n  end\n}\n\nbox_chars = {\n  h: \"─\"\n  v: \"│\"\n  bl: \"╰\"\n  br: \"╯\"\n  tl: \"╭\"\n  tr: \"╮\"\n}\n\ndoprintline:.defcase {\n  horizontal: (x y dx char)\n    => x .-> (x + dx) .each i\n      => term.cell\\set(i y char)\n  vertical: (x y dy char)\n    => y .-> (y + dy) .each i\n      => term.cell\\set(x i char)\n}\n\nprintline = (x y opts{})\n  => opts.axis.doprintline(x y opts.dist, opts.char)\n\nprintbox = (x y w h) => do\n  term.cell\\set(x y box_chars.tl)\n  term.cell\\set(x + w y box_chars.tr)\n  term.cell\\set(x y + h box_chars.bl)\n  term.cell\\set(x + w y + h box_chars.br)\n\n  printline.(\n    x + 1\n    y\n    char: box_chars.h\n    axis: horizontal:\n    dist: w - 2)\n\n  printline.(\n    x\n    y + 1\n    char: box_chars.v\n    axis: vertical:\n    dist: h - 2)\n\n  printline.(\n    x + 1\n    y + h\n    char: box_chars.h\n    axis: horizontal:\n    dist: w - 2)\n\n  printline.(\n    x + w\n    y + 1\n    char: box_chars.v\n    axis: vertical:\n    dist: h - 2)\nend\n\nTicker = Fibers.make () => do\n  events <! { type: tick: }\n\n  Fibers.sleep!(100000000)\n\n  events.closed?.else self\nend\n\nClient = Fibers.make() \n  => events\n  .reduce(\n    REPLClient:.make, # Initial state\n    (state event) => do\n      term.clear!\n\n      #term.print!(0, 0, \"$\".sprintf event)\n\n      state = event.type.event\\handle(state, event)\n\n      (w h) = (term.width, term.height)\n\n      state.history.each (h, i) => do\n        source_line = \"$: $\".sprintf(i, h.source)\n        term.print!(0, 3 + (i * 2), source_line)\n\n        result_line = h.result.to\\s\n        term.print!(0, 4 + (i * 2), result_line)\n      end\n\n      printbox.(0 h - 3 w - 2 2)\n      input_line = \" > $\".sprintf(state.input)\n      term.print!(1, h - 2, input_line)\n\n      term.render!\n\n      state\n    end)\n\n[Main Server Client Ticker]\n  .map await!:\n  .map unwrap!:\n","textDocument":{"uri":"file:///home/tr/repos/cgab/repl/mod.gab"}}}Content-Length: 5725

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"text":"'cgab'.use\n'ranges'.use\nxf = 'transducers'.use\nTerminal = 'os.terminal'.use\n\nterm = Terminal.make\n\n(events, server) = (Channels.make, Channels.make)\n\nevent\\quit:.def(\n  Records.t,\n  () => self.ch == 'q')\n\n# Fiber for polling terminal events and pushing them\n# into a channel for handling. Transducer terminates\n# the stream on the quit event.\nMain = Fibers.make () => do\n  term.pipe(\n    events\n    xf.take_until event\\quit?:)\n\n# Close all channels at this point.\n  events.close!\n  server.close!\nend\n\nHistoryElement = Shapes.make(source: result:)\n\nto\\s:.defcase {\n  Shapes.make(status: fiber:) () => do\n   \"=> $ $\".sprintf(self.status, self.fiber)\n  end\n  Shapes.make(status: res: env:) () => do\n    \"=> $ $\".sprintf(self.status, self.res.map to\\s: .join(xf.interpose \" \"))\n  end\n}\n\nEvalCmd = Shapes.make(eval:)\nEnvCmd = Shapes.make(env:)\n\ntick\\history_element\\result:.defcase {\n  Shapes.make(status: fiber:) (he) => do\n    result = he.result\n    fib = result.fiber\n\n    fib\n      .then done?:\n      .then(() => do\n        (status, res[], env) = fib.await!\n\n        status\n          .ok?\n          .then(() => server <! EnvCmd.make(env))\n\n        he.result {\n          status: status\n          res: res\n          env: env\n        }\n      end)\n      .or he\n  end\n  Shapes.make(status: res: env:) (he) => he\n}\n\ntick\\history_element:.def(\n  HistoryElement\n  () => self.result.tick\\history_element\\result self)\n\ncmd\\handle:.defcase {\n  EvalCmd (state) => do\n    (ok, fib) = self.eval.gab\\eval(state.env)\n\n    server <! { status: ok, fiber: fib }\n\n    state\n  end\n  EnvCmd (state) => do\n    state.env(self.env)\n  end\n}\n\nREPLServer = Shapes.make(env:)\n\nmake:.def(\n  REPLServer:\n  () => REPLServer.make(nil:))\n\nrun:.def(\n  REPLServer:\n  ()\n    => Fibers.make ()\n      => server.reduce(\n        REPLServer:.make,\n        (state, cmd)\n          => cmd.cmd\\handle state))\n\nServer = REPLServer:.run\n\nREPLClient = Shapes.make(input: history_index: history:)\n\nmake:.def(\n  REPLClient:,\n  () => REPLClient.make(\"\" 0 []))\n\nevent\\ctrl\\key\\handle:.def (state) => state\n\nevent\\ctrl\\key\\handle:.defcase {\n  backspace: (state, event) => do\n    input = state.input.slice(0, state.input.len - 1)\n    state.input input\n  end\n  enter: (state, event) => do\n    server <! EvalCmd.make(state.input)\n\n    (ok, res) = server >!\n\n    history_elem = HistoryElement.make(state.input, res)\n\n    state = ok\n      .and state.history(state.history.push history_elem)\n      .or state\n      .input \"\"\n\n    state.history_index(state.history.len)\n  end\n}\n\nevent\\key\\key\\handle:.defcase {\n  arrow\\down: (state, event) => do\n    state = state.history_index(state.history_index ++)\n    (ok, hist) = state.history.at(state.history_index)\n\n    ok\n      .then(() => state.input(hist.source))\n      .else(() => state.input \"\")\n  end\n  arrow\\up: (state, event) => do\n    state = state.history_index(state.history_index --)\n    (ok, hist) = state.history.at(state.history_index)\n\n    ok\n      .then(() => state.input(hist.source))\n      .else(() => state.input \"\")\n  end\n}\n\nevent\\key\\key\\handle:.def (state event) =>  do\n  input = state.input + event.ch\n  state.input input\nend\n\nevent\\key\\handle:.defcase {\n  ctrl: (state, event) => event.key.event\\ctrl\\key\\handle(state event),\n  key: (state, event) => event.key.event\\key\\key\\handle(state event)\n}\n\nevent\\handle:.defcase {\n  key: (state, event) => event.mod.event\\key\\handle(state event)\n  tick: (state) => do\n    state.history(state.history.map tick\\history_element:)\n  end\n}\n\nbox_chars = {\n  h: \"─\"\n  v: \"│\"\n  bl: \"╰\"\n  br: \"╯\"\n  tl: \"╭\"\n  tr: \"╮\"\n}\n\ndoprintline:.defcase {\n  horizontal: (x y dx char)\n    => x .-> (x + dx) .each i\n      => term.cell\\set(i y char)\n  vertical: (x y dy char)\n    => y .-> (y + dy) .each i\n      => term.cell\\set(x i char)\n}\n\nprintline = (x y opts{})\n  => opts.axis.doprintline(x y opts.dist, opts.char)\n\nprintbox = (x y w h) => do\n  term.cell\\set(x y box_chars.tl)\n  term.cell\\set(x + w y box_chars.tr)\n  term.cell\\set(x y + h box_chars.bl)\n  term.cell\\set(x + w y + h box_chars.br)\n\n  printline.(\n    x + 1\n    y\n    char: box_chars.h\n    axis: horizontal:\n    dist: w - 2)\n\n  printline.(\n    x\n    y + 1\n    char: box_chars.v\n    axis: vertical:\n    dist: h - 2)\n\n  printline.(\n    x + 1\n    y + h\n    char: box_chars.h\n    axis: horizontal:\n    dist: w - 2)\n\n  printline.(\n    x + w\n    y + 1\n    char: box_chars.v\n    axis: vertical:\n    dist: h - 2)\nend\n\nTicker = Fibers.make () => do\n  events <! { type: tick: }\n\n  Fibers.sleep!(100000000)\n\n  events.closed?.else self\nend\n\nClient = Fibers.make() \n  => events\n  .reduce(\n    REPLClient:.make, # Initial state\n    (state event) => do\n      term.clear!\n\n      #term.print!(0, 0, \"$\".sprintf event)\n\n      state = event.type.event\\handle(state, event)\n\n      (w h) = (term.width, term.height)\n\n      state.history.each (h, i) => do\n        source_line = \"$: $\".sprintf(i, h.source)\n        term.print!(0, 3 + (i * 2), source_line)\n\n        result_line = h.result.to\\s\n        term.print!(0, 4 + (i * 2), result_line)\n      end\n\n      printbox.(0 h - 3 w - 2 2)\n      input_line = \" > $\".sprintf(state.input)\n      term.print!(1, h - 2, input_line)\n\n      term.render!\n\n      state\n    end)\n\n[Main Server Client Ticker]\n  .map await!:\n  .map unwrap!:\n","textDocument":{"uri":"file:///home/tr/repos/cgab/repl/mod.gab"}}}Content-Length: 2945

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/tr/repos/cgab/lsp/server.gab","languageId":"gab","version":0,"text":"'Json'.use\n\nlog = 'lsp/logs'.use\n\ndiag\\job\\t = Shapes.make(server: uri: text:)\nlsp\\server\\t = Shapes.make(server\\in: server\\out: server\\open_ch: server\\data:)\n\nmake:.def(\n  lsp\\server:\n  (in out) => lsp\\server\\t.make(\n    in .or (IO.stdin)\n    out .or (IO.stdout)\n    Channels.make\n    {}))\n\nt:.def(lsp\\server: lsp\\server\\t)\n\nlogfile = IO\n  .file(\"/tmp/lsprpc.log\" \"w\")\n  .unwrap\n\n_read_header:.defcase {\n  ok: (lsp m) => do\n    next_header = lsp\n      .server\\in\n      .until('\\n'.to\\b)\n      .unwrap\n      .trim '\\n'\n\n    (blank name value) = (next_header.is\\blank, next_header.split ':')\n    \n    m = blank .and m .or(m.put(name, value))\n\n    logfile.write(next_header + '\\n')\n\n    option:.(blank!, lsp, m)._read_header\n  end\n  none: (lsp m) => m\n}\n\n[lsp\\server\\t].defmodule {\n  _read_headers: () => do\n    ok:._read_header(self, [])\n  end\n  _read_request: () => do\n    headers = self._read_headers\n\n    log.(headers: headers)\n\n    len = headers\n      .at \"Content-Length\"\n      .unwrap\n      .trim\n      .as\\n\n\n    body = self\n      .server\\in\n      .scan len\n      .unwrap\n\n    logfile.write(body)\n\n    msg = body\n      .as\\json\n      .unwrap\n\n    msg\n  end,\n  # Implement the lazy-sequence protocol\n  seq\\init: () => do\n    msg = self._read_request\n    option:.(self.server\\open_ch.is\\open, nil: msg)\n  end\n  seq\\next: () => do\n    msg = self._read_request\n    option:.(self.server\\open_ch.is\\open, nil: msg)\n  end\n  # Helpers for sending data to client\n  respond: (id result) => do\n    msg = { \"id\" id \"result\" result } .to\\json\n\n    content\\length = msg.len\n\n    res = Strings.make(\n      'Content-Length:'content\\length\n      '\\r\\n\\r\\n'msg)\n\n    log.(\"Response\" id res)\n\n    self.server\\out.write res .unwrap\n  end\n  notify: (method params) => do \n    log.(\"Notification\" method params?)\n\n    msg = { \"method\" method \"params\" params } .to\\json\n\n    log.(\"Notification\" msg)\n\n    content\\length = msg.len\n\n    notif = Strings.make(\n      'Content-Length:'content\\length\n      '\\r\\n\\r\\n'msg)\n\n    self.server\\out.write notif .unwrap\n  end\n  # Run the server\n  run: () => do\n    log.\"Server started!\"\n\n    self.reduce(self (lsp req) => do\n      msg = req .lsp\\messages\\into\n\n      log.(\"Received Msg\", msg)\n\n      (ok new_lsp) = msg .lsp\\dispatch lsp\n\n      ok .else () => do\n        log.(\"No handler found.\")\n      end\n\n      (new_lsp? == lsp\\server\\t) .else () => do\n        log.error(\"Invalid new_lsp\", ok, new_lsp)\n      end\n\n      ok .then () => log.(\"Successfully processed msg\")\n\n      ok.== ok: .and new_lsp .or lsp\n    end)\n  end,\n}\n\nlsp\\server:\n"}}}Content-Length: 2820

{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/tr/repos/cgab/lsp/messages.gab","languageId":"gab","version":0,"text":"log = 'lsp/logs'.use\n'lsp/diagnostics'.use\n\nlsp\\messages\\into:.def(\n  Records.t\n  () => do\n    (ok, method) = self.at 'method'\n\n    ok .else () => do\n      log.error(\"No Method\", self)\n    end\n\n    (ok, params) = self.at 'params'\n\n    method = method.or \"\" .to\\m\n    params = params.or {}\n    (ok, id) = self .at 'id'\n\n    id = ok.== ok: .and id .or 1\n\n    {\n      method nil:,\n      id: id,\n      params: params,\n    }\n  end)\n\ndef\\lsp\\handler:.def(\n  Strings.t\n  handler => do\n    lsp\\handle:.def(Shapes.make(self.to\\m, id:, params:), handler)\n  end)\n\n# Dispatch a message into its handler, if we have one\nlsp\\dispatch:.def(\n  server => do\n    message = self\n\n    lsp\\handle:.at message .then () => do\n        log.(\"Dispatch\" lsp\\handle:.at message)\n        (ok: message.lsp\\handle server)\n    end\n  end)\n\n\n#\n# INITIALIZATION\n#\n\nTEXTDOCUMENTSYNCKIND\\FULL = 1\n\n'initialize' .def\\lsp\\handler server => do\n  server.respond(\n    self.id,\n    {\n        \"capabilities\" {\n          \"textDocumentSync\" {\n            \"openClose\" true:,\n            #\"change\": TEXTDOCUMENTSYNCKIND\\FULL,\n            \"save\" {\n              \"includeText\" true:,\n            },\n          },\n        },\n        \"serverInfo\" {\n          \"name\" \"gablsp\",\n          \"version\" \"0.0.1\",\n        },\n      })\n\n  server\nend\n\n'initialized' .def\\lsp\\handler server => do\n  server\nend\n\n'shutdown' .def\\lsp\\handler server => do\n  log.(\"Shutting down\")\n\n  server.server\\open_ch.close\n\n  server\nend\n\n#\n# SYNCHRONIZATION\n#\n\n\"textDocument/didOpen\" .def\\lsp\\handler server => do\n  uri = self.params.at 'textDocument' .unwrap.at 'uri' .unwrap\n  text= self.params.at 'textDocument' .unwrap.at 'text' .unwrap\n\n  log.(\"Opened\", uri)\n\n  data = server.server\\data.put(uri, text)\n\n  server = server.put(server\\data: data)\n\n  server.diagnostics\\queue_all\n\n  server\nend\n\n\"textDocument/didSave\" .def\\lsp\\handler server => do\n  uri = self.params.at 'textDocument' .unwrap.at 'uri' .unwrap\n  (ok, text) = self.params.at 'text'\n\n  log.(\"Saved\", uri)\n\n  data = server.server\\data.put(uri, text)\n\n  updated_server = server.put(server\\data: data)\n\n  updated_server.diagnostics\\queue(text uri)\n\n  (ok, updated_server) .unwrap.or (server)\nend\n\n\"textDocument/didClose\" .def\\lsp\\handler server => do\n  # TODO: Delete documents from the server data on load\n  server\nend\n\n\"textDocument/didChange\" .def\\lsp\\handler server => do\n  # TODO: Handle incremental changes in documents\n  server\nend\n\n\n#\n# DIAGNOSTICS\n#\n"}}}Content-Length: 2796

{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"text":"log = 'lsp/logs'.use\n'lsp/diagnostics'.use\n\nlsp\\messages\\into:.def(\n  Records.t\n  () => do\n    (ok, method) = self.at 'method'\n\n    ok .else () => do\n      log.error(\"No Method\", self)\n    end\n\n    (ok, params) = self.at 'params'\n\n    method = method.or \"\" .to\\m\n    params = params.or {}\n    (ok, id) = self .at 'id'\n\n    id = ok.== ok: .and id .or 1\n\n    {\n      method nil:,\n      id: id,\n      params: params,\n    }\n  end)\n\ndef\\lsp\\handler:.def(\n  Strings.t\n  handler => do\n    lsp\\handle:.def(Shapes.make(self.to\\m, id:, params:), handler)\n  end)\n\n# Dispatch a message into its handler, if we have one\nlsp\\dispatch:.def(\n  server => do\n    message = self\n\n    lsp\\handle:.at message .then () => do\n        log.(\"Dispatch\" lsp\\handle:.at message)\n        (ok: message.lsp\\handle server)\n    end\n  end)\n\n\n#\n# INITIALIZATION\n#\n\nTEXTDOCUMENTSYNCKIND\\FULL = 1\n\n'initialize' .def\\lsp\\handler server => do\n  server.respond(\n    self.id,\n    {\n        \"capabilities\" {\n          \"textDocumentSync\" {\n            \"openClose\" true:,\n            #\"change\": TEXTDOCUMENTSYNCKIND\\FULL,\n            \"save\" {\n              \"includeText\" true:,\n            },\n          },\n        },\n        \"serverInfo\" {\n          \"name\" \"gablsp\",\n          \"version\" \"0.0.1\",\n        },\n      })\n\n  server\nend\n\n'initialized' .def\\lsp\\handler server => do\n  server\nend\n\n'shutdown' .def\\lsp\\handler server => do\n  log.(\"Shutting down\")\n\n  server.server\\open_ch.close\n\n  server\nend\n\n#\n# SYNCHRONIZATION\n#\n\n\"textDocument/didOpen\" .def\\lsp\\handler server => do\n  uri = self.params.at 'textDocument' .unwrap.at 'uri' .unwrap\n  text= self.params.at 'textDocument' .unwrap.at 'text' .unwrap\n\n  log.(\"Opened\", uri)\n\n  data = server.server\\data.put(uri, text)\n\n  server = server.put(server\\data: data)\n\n  server.diagnostics\\queue(text, uri)\n\n  server\nend\n\n\"textDocument/didSave\" .def\\lsp\\handler server => do\n  uri = self.params.at 'textDocument' .unwrap.at 'uri' .unwrap\n  (ok, text) = self.params.at 'text'\n\n  log.(\"Saved\", uri)\n\n  data = server.server\\data.put(uri, text)\n\n  updated_server = server.put(server\\data: data)\n\n  updated_server.diagnostics\\queue(text uri)\n\n  (ok, updated_server) .unwrap.or (server)\nend\n\n\"textDocument/didClose\" .def\\lsp\\handler server => do\n  # TODO: Delete documents from the server data on load\n  server\nend\n\n\"textDocument/didChange\" .def\\lsp\\handler server => do\n  # TODO: Handle incremental changes in documents\n  server\nend\n\n\n#\n# DIAGNOSTICS\n#\n","textDocument":{"uri":"file:///home/tr/repos/cgab/lsp/messages.gab"}}}Content-Length: 44

{"method":"shutdown","jsonrpc":"2.0","id":2}