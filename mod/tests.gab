is\unittest:.def(
  Messages.t
  () => self.to\s.has\ending "\test")

implementations = Messages.specializations

xf = Streams.filter((_ m) => m.is\unittest)
  |> Streams.map((impls m) => do
      (path*, _) = m.to\s.split "\"

      (path { path: path, impls: impls })
  end)

# Collect all the implementations into a giant, nested map.
tests\all = implementations.transduce(
  {}
  (t p i) => t.put_via(i p*)
  xf
)

suites\all = tests\all.reduce(
  {}
  (suites _ suite) => suites.put(suite Channels.make)
)

test\compare: .def (
  Blocks.t, Messages.t
  (lhs rhs) => self.(lhs, rhs)
)

test\result\t = { test\path: nil: test\receiver: nil: }?

[test\result\t] .defmodule {
  expect: (lhs cmp rhs) => do
    # Run the comparison of the expect
    test\outcome = cmp .test\compare (lhs, rhs)
    # Get the suite we're executing
    suite = self.test\path .at 0 .unwrap
    chan = suites\all .at suite .unwrap
    # Queue up the outcome of the comparison
    chan <! (test\outcome, self.test\path, { lhs: lhs, cmp: cmp, rhs: rhs })
  end,
}


render_results = (suite\result) => do
  s = suite\result.suite
  r = suite\result.results

  successes = r.filter test\outcome:
  failures  = r.skip test\outcome:

  failures.is\empty.then () => do
    test_successes = successes
      .transduce({} put: Streams.map p => p.test\path.join(Streams.interpose ' should '))

    'PASS | $: $ assertions passed in $ unique tests\n'.printf(s.to\s, successes.len.to\s, test_successes.len.to\s)
    #test_successes.each (_, p) => '  $\n'.printf(p)

    ok:
  end .else () => do
    'FAIL | $: $ assertions failed\n'.printf(s.to\s, failures.len.to\s)
  end
end

watcher = Fibers.make () => do
  suite\results = suites\all .map (c s) => do
    results = c.collect(Streams.map (outcome, path, meta)
      => { test\outcome: outcome, test\path: path test\meta: meta})

    { suite: s results: results }
  end

  suite\results.each render_results
end

() => do
  'Discovered $ test suites.\n'.printf(tests\all.len.to\s)
  fibers = tests\all.map (behaviors suite) => do 
      Fibers.make () => do
        '\nRunning suite $\n'.printf(suite.to\s)
        behaviors.each (runnable behavior) => do 
          (path body) = runnable*
          '\r\t$'.printf(path.join.to\s)
          body.each(t r) => do
            t.{ test\path: path, test\receiver: r }
          end
        end
        '\r\t                  '.printf

        suites\all
          .at suite
          .unwrap
          .close
      end
    end

  fibers.each await:
  watcher.await
end

