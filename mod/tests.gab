'cgab'.use
ui = 'cgui'.use

(events, app) = (Channels.make, Channels.make)

ui.run\tui(events, app)

is\unittest:.def(
  Messages.t
  () => self.to\s.has\ending "\test")

implementations = Messages.specializations

xf = Streams.filter((_ m) => m.is\unittest)
  |> Streams.map((impls m) => do
      (path*, _) = m.to\s.split "\"

      (path { path: path, impls: impls })
  end)

# Collect all the implementations into a giant, nested map.
tests\all = implementations.transduce(
  {}
  (t p i) => t.put_via(p*, i)
  xf
)

suites\all = tests\all.reduce(
  {}
  (suites _ suite) => suites.put(suite Channels.make)
)

test\compare: .def (
  Blocks.t, Messages.t
  (lhs rhs) => self.(lhs, rhs)
)

test\result\t = { test\path: nil: test\receiver: nil: }?

[test\result\t] .defmodule {
  expect: (lhs cmp rhs) => do
    # Run the comparison of the expect
    behavior\outcome = cmp .test\compare (lhs, rhs)
    # Get the suite we're executing
    suite = self.test\path .at 0 .unwrap
    chan = suites\all .at suite .unwrap
    # Queue up the outcome of the comparison
    chan <! (behavior\outcome, self.test\path, { lhs: lhs, cmp: cmp, rhs: rhs })
  end,
}


render_results = (suite\result) => do
  s = suite\result.suite
  r = suite\result.results

  successes = r.filter behavior\outcome:
  failures  = r.skip behavior\outcome:

  failures.is\empty.then () => do
    test_successes = successes
      .transduce({} put: Streams.map p => p.test\path.join(Streams.interpose ' should '))

    'PASS | $: $ assertions passed in $ unique tests\n'.printf(s.to\s, successes.len.to\s, test_successes.len.to\s)
    #test_successes.each (_, p) => '  $\n'.printf(p)

    ok:
  end .else () => do
    'FAIL | $: $ assertions failed\n'.printf(s.to\s, failures.len.to\s)
  end
end

clear_screen = () => '\e[2J\e[H'.printf

Suite = test\suite:.defclass(
  suite\behaviors: suite\name:
  default:
  {
    suite\render: () => do
      '\t$\n'.printf(self.suite\name.to\s) 
      self
        .suite\behaviors
        .each behavior\render:
    end
  })

behavior\render: .defcase {
  true:  t => 'P   $\n'.printf(t.behavior\path.at 1 .unwrap)
  nil:   t => '... $\n'.printf(t.behavior\path.at 1 .unwrap)
  false: t => 'F   $\n'.printf(t.behavior\path.at 1 .unwrap)
}

Behavior = test\behavior:.defclass(
  behavior\path: behavior\meta: behavior\outcome:
  default:
  {
    behavior\render: () => self.behavior\outcome.behavior\render self
  })

handle\keydown: .defcase {
  Messages.t
  (ev model) => model
}

handle\keyup: .defcase {
  Messages.t
  (ev model) => model
}

handle\key: .defcase {
  true: (msg ev model) => msg.handle\keydown(ev model)
  false: (msg ev model) => msg.handle\keyup(ev model)
}

handle\type: .defcase {
  tick:  (ev model) => do
    # Tick time
    model
  end
  mouse: (ev model) => do
    model
  end
  key:   (ev model) => do
    keymsg = ev.at 0 .unwrap
    down = ev.at 2 .unwrap
    down.handle\key(keymsg ev model)
  end
  suite: (ev model) => do
    suite = ev .at 0 .unwrap
    model.app\push_suite(suite)
  end
  behavior: (ev model) => do
    behavior = ev .at 0 .unwrap
    model.app\push_behavior(behavior)
  end
  resolve: (ev model) => do
    model.app\resolve_behavior(ev*)
  end
}

App = test\app:.defclass(
  test\suites: test\tests:
  default:
  {
    app\controller: (type ev*) => do
      #'$  $\n'.printf(type, ev)
      type.handle\type(ev self)
    end
    app\view: () => do
      [
        [
          box:
          { width\relative: 100 padding: 32 }
          [[text: { size: 32 content: "Hello" }]]
        ]
      ]
    end
    app\push_suite: (suite) => do
      self
        .put_via(test\suites:, suite.suite\name, suite)
    end
    app\push_behavior: (behavior) => do
      suite = behavior.behavior\path.at 0 .unwrap
      bhv = behavior.behavior\path.at 1 .unwrap

      self
        .put_via(test\suites: suite suite\behaviors: bhv behavior)
    end
    app\resolve_behavior: (outcome path meta) => do
      suite = path.at 0 .unwrap
      bhv = path.at 1 .unwrap
      self
        .put_via(test\suites: suite suite\behaviors: bhv behavior\outcome: outcome)
        .put_via(test\suites: suite suite\behaviors: bhv behavior\meta: meta)
    end
  })

Fibers.make () => do
  fibers = tests\all.map (behaviors suite) => do 
      events <! (suite: Suite.make([] suite))

      Fibers.make () => do
        behaviors.each (runnable behavior) => do 
          (path body) = runnable*

          events <! (behavior: Behavior.make(path nil: nil:))

          body.each(t r) => do
            t.{ test\path: path, test\receiver: r }
          end
        end

        suites\all
          .at suite
          .unwrap
          .close
      end
  end

  watchers = suites\all .map (c s) => do
    Fibers.make () => do 
      c.collect(Streams.map (outcome path meta) => do
        events <! (resolve: outcome path meta)
      end)
    end
  end
end

model = App.make({} {})

events
  .pipe(
    app,
    Streams.take_until((e, key) => do
      [e, key].eprintln

      (e == key:) & (key == escape:)
    end)
    |> Streams.reduce(model app\controller:)
    #|> Streams.tap(eprintln:)
    |> Streams.map(app\view:)
    #|> Streams.tap(eprintln:)
  )

app.close
events.close
