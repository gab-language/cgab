'cgab'.use
ui = 'cgui'.use

img = IO.Files.make("vendor/RGFW/logo.png" "r").unwrap

imgdata = img.read(img.len)

(events, app) = (Channels.make, Channels.make)

Colors = {
  bg: "0x161821".as\n
  fg: "0xcdd6f5".as\n
  bg\hl: "0x272c42".as\n
  fg\hl: "0xc6c8d1".as\n
  r: "0xf38ba9".as\n
  o: "0xfab388".as\n
  y: "0xf9e2b0".as\n
  g: "0xa6e3a2".as\n
  b: "0x89b4fb".as\n
  i: "0x94e2d6".as\n
  v: "0xcba6f8".as\n
}

Spacer = [ box: { width\grow: 10 } [] ]

ui
  .run\tui(events, app)
  .unwrap

is\unittest:.def(
  Messages.t
  () => self.to\s.has\ending "\test")

implementations = Messages.specializations

xf = Streams.filter((_ m) => m.is\unittest)
  |> Streams.map((impls m) => do
      (path*, _) = m.to\s.split "\"

      (path { path: path, impls: impls })
  end)

# Collect all the implementations into a giant, nested map.
tests\all = implementations.transduce(
  {}
  (t p i) => t.put_via(p*, i)
  xf
)

suites\all = tests\all.reduce(
  {}
  (suites _ suite) => suites.put(suite Channels.make)
)

test\compare: .defcase {
  Blocks.t, (lhs rhs) => self.(lhs, rhs)

  ==: (lhs rhs) => lhs == rhs

  <: (lhs rhs) => lhs < rhs

  is\nan: (lhs) => lhs.is\nan

  is\inf: (lhs) => lhs.is\inf
}

test\result\t = { test\path: nil: test\receiver: nil: }?

[test\result\t] .defmodule {
  expect: (lhs cmp rhs) => do
    # Run the comparison of the expect
    behavior\outcome = cmp .test\compare (lhs, rhs)
    # Get the suite we're executing
    suite = self.test\path .at 0 .unwrap
    # Queue up the outcome of the comparison
    events <! (resolve: behavior\outcome, self.test\path, { lhs: lhs, cmp: cmp, rhs: rhs })
  end,
}

Suite = test\suite:.defclass(
  suite\behaviors: suite\name:
  default:
  {
  })

Behavior = test\behavior:.defclass(
  behavior\path: behavior\meta: behavior\outcome:
  default:
  {
  })

queue_tests = (filter_by_suite) => do
  Fibers.make () => do
    xf = Streams.map (behaviors suite) => do
        events <! (suite: Suite.make([] suite))

        Fibers.make () => do
          behaviors.each (runnable behavior) => do 
            (path body) = runnable*

            events <! (behavior: Behavior.make(path nil: nil:))

            body.each(t r) => do
              t.{ test\path: path, test\receiver: r }
            end

            ok:
          end

          suites\all
            .at suite
            .unwrap
            .close
        end
    end

    xf = filter_by_suite.== nil: .!
        .then(() => do
          Streams.filter((_, suite) => filter_by_suite == suite)
          |> xf
        end)
        .or xf
    
    fibers = tests\all.collect([] xf)

    fibers.map f => f.await

    #TODO: Make this configurable from the cmdline
    #events.close
    #app.close
  end
end

handle\keydown: .defcase {
  r: (ev model) => do
    queue_tests.()
    model.app\reset
  end
  k: (ev model) => do
    model.put_by(selected: (old) => do
      (old == 0)
        .and old
        .or(old--)
    end)
  end
  j: (ev model) => do
    len = suites\all.len
    model.put_by(selected: (old) => do
      (old == (len - 1))
        .and old
        .or(old++)
    end)
  end
  Messages.t
  (ev model) => model
}

handle\keyup: .defcase {
  Messages.t
  (ev model) => model
}

handle\key: .defcase {
  true: (msg ev model) => msg.handle\keydown(ev model)
  false: (msg ev model) => msg.handle\keyup(ev model)
}

handle\type: .defcase {
  tick:  (ev model) => do
    # Tick time
    model.put_via_by(time: t => t++)
  end
  mouse: (ev model) => do
    model
  end
  key:   (ev model) => do
    keymsg = ev.at 0 .unwrap
    down = ev.at 2 .unwrap
    down.handle\key(keymsg ev model)
  end
  suite: (ev model) => do
    suite = ev .at 0 .unwrap
    model.app\push_suite(suite)
  end
  behavior: (ev model) => do
    behavior = ev .at 0 .unwrap
    model.app\push_behavior(behavior)
  end
  resolve: (ev model) => do
    model.app\resolve_behavior(ev*)
  end
}

spinner = "⣾⣾⣽⣽⣻⣻⢿⢿⡿⡿⣟⣟⣯⣯⣷⣷".collect []

App = test\app:.defclass(
  test\suites: test\tests: time: selected:
  default:
  {
    app\controller: (type ev*) => do
      type.handle\type(ev self)
    end
    app\reset: () => do
      self
        .put(test\suites: {})
        .put(test\tests: {})
    end
    app\push_suite: (suite) => do
      self
        .put_via(test\suites:, suite.suite\name, suite)
    end
    app\push_behavior: (behavior) => do
      suite = behavior.behavior\path.at 0 .unwrap
      bhv = behavior.behavior\path.at 1 .unwrap

      self
        .put_via(test\suites: suite suite\behaviors: bhv behavior)
    end
    app\resolve_behavior: (outcome path meta) => do
      suite = path.at 0 .unwrap
      bhv = path.at 1 .unwrap
      self
        .put_via(test\suites: suite suite\behaviors: bhv behavior\outcome: outcome)
        .put_via(test\suites: suite suite\behaviors: bhv behavior\meta: meta)
        .put_via(test\suites: suite suite\behaviors: bhv behavior\path: path)
    end
    app\view: () => do
      app = self

      (ok, selected_key) = app.test\suites.?.at(app.selected)
      (has_selected, selected) = ok.then () => app.test\suites.at(selected_key)

      [
        [
          box:
          {
            h\g: 1
            w\g: 1
            layout: horizontal:
            bg: Colors.bg
          }
          [
            [
              img:
              {
                w: 900,
                h: 900,
                content: imgdata,
              }
            ]
            [
              box:
              {
                p\x: 9
                p\y: 21
                h\g: 1
                w\r: 50
                border: { w: 1 fg: Colors.bg\hl }
                bg: Colors.bg
              }
              self.test\suites.map (suite, name) => do
                pass_behaviors = suite
                  .suite\behaviors
                  .collect([] Streams.filter (b => b.behavior\outcome == true:))

                fail_behaviors = suite
                  .suite\behaviors
                  .collect([] Streams.filter(b => b.behavior\outcome == false:))

                waiting = suites\all .at name .unwrap .is\closed.!

                spinner_char = (waiting)
                  .then(() => spinner.at(app.time % spinner.len).unwrap)
                  .or " "

                color = (selected == suite).and(Colors.r).or(Colors.fg)

                [
                  box:
                  {
                    layout: horizontal:
                    w\g: 1
                    bg: Colors.bg
                  }
                  [
                    [
                      text:
                      {
                        w\g: 1
                        fg: color
                        size: 32
                        content: "$ $".sprintf(spinner_char, name)
                      }
                    ]
                    [
                      text:
                      {
                        p\h: 1
                        fg: Colors.g
                        size: 32
                        content: "✔ $".sprintf(pass_behaviors.len)
                      }
                    ]
                    [
                      text:
                      {
                        p\h: 1
                        fg: Colors.r
                        size: 32
                        content: "✘ $".sprintf(fail_behaviors.len)
                      }
                    ]
                  ]
                ]
              end
            ]
            [
              box:
              {
                p\x: 9
                p\y: 21
                h\g: 1
                w\g: 1
                border: { w: 1 fg: Colors.bg\hl }
                bg: Colors.bg
              }
              has_selected
                .then(() => do
                  selected
                    .suite\behaviors
                    .map((bhv) => do
                      [
                        text:
                        {
                          size: 32
                          content: bhv.behavior\path.join("" Streams.interpose "should" |> Streams.interpose " ")
                        }
                      ]
                    end)
                end)
                .or([[text: { size: 32 content: "none" }]])
            ]
          ]
        ]
      ]
    end
  })

model = App.make({} {} 0 0)

queue_tests.()

events
  .pipe(
    app,
    Streams.take_until((e, key) => do
      (e == key:) & ((key == escape:) | (key == q:))
    end)
    |> Streams.reduce(model (model, args*) => model.app\controller (args*))
    |> Streams.map(app => app.app\view)
  )

app.close
events.close
