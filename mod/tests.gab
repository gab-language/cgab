'cgab'.use
ui = 'cgui'.use

(events, app) = (Channels.make, Channels.make)

Colors = {
  bg: "0x161821".as\n
  fg: "0xcdd6f5".as\n
  bg\hl: "0x272c42".as\n
  fg\hl: "0xc6c8d1".as\n
  r: "0xf38ba9".as\n
  o: "0xfab388".as\n
  y: "0xf9e2b0".as\n
  g: "0xa6e3a2".as\n
  b: "0x89b4fb".as\n
  i: "0x94e2d6".as\n
  v: "0xcba6f8".as\n
}

Spacer = [ box: { width\grow: 10 } [] ]

ui
  .run\tui(events, app)
  .unwrap

is\unittest:.def(
  Messages.t
  () => self.to\s.has\ending "\test")

implementations = Messages.specializations

xf = Streams.filter((_ m) => m.is\unittest)
  |> Streams.map((impls m) => do
      (path*, _) = m.to\s.split "\"

      (path { path: path, impls: impls })
  end)

# Collect all the implementations into a giant, nested map.
tests\all = implementations.transduce(
  {}
  (t p i) => t.put_via(p*, i)
  xf
)

suites\all = tests\all.reduce(
  {}
  (suites _ suite) => suites.put(suite Channels.make)
)

test\compare: .defcase {
  Blocks.t, (lhs rhs) => self.(lhs, rhs)

  ==: (lhs rhs) => lhs == rhs

  <: (lhs rhs) => lhs < rhs

  is\nan: (lhs) => lhs.is\nan

  is\inf: (lhs) => lhs.is\inf
}

test\result\t = { test\path: nil: test\receiver: nil: }?

[test\result\t] .defmodule {
  expect: (lhs cmp rhs) => do
    # Run the comparison of the expect
    assertion\outcome = cmp .test\compare (lhs, rhs)
    # Get the suite we're executing
    suite = self.test\path .at 0 .unwrap
    # Queue up the outcome of the comparison
    events <! (resolve: assertion\outcome, self.test\path, { lhs: lhs, cmp: cmp, rhs: rhs })
  end,
}

Suite = test\suite:.defclass(
  suite\behaviors: suite\name:
  default:
  {})

Assertion = test\assertion:.defclass(
  assertion\meta: assertion\outcome:
  default:
  {})

Behavior = test\behavior:.defclass(
  behavior\show: behavior\path: behavior\assertions:
  default:
  {})

queue_tests = (filter_by_suite) => do
  Fibers.make () => do
    xf = Streams.map (behaviors suite) => do
        events <! (suite: Suite.make([] suite))

        Fibers.make () => do
          behaviors.each (runnable behavior) => do 
            (path body) = runnable*

            events <! (behavior: Behavior.make(false: path []))

            body.each(t r) => do
              t.{ test\path: path, test\receiver: r }
            end

            ok:
          end

          suites\all
            .at suite
            .unwrap
            .close
        end
    end

    xf = filter_by_suite.== nil: .!
        .then(() => do
          Streams.filter((_, suite) => filter_by_suite == suite)
          |> xf
        end)
        .or xf
    
    fibers = tests\all.collect([] xf)

    fibers.map f => f.await

    #TODO: Make this configurable from the cmdline
    #events.close
    #app.close
  end
end

select\up: .defcase {
  suite: (model) => do
    model.put_by(selected\suite: (old) => do
      (old == 0)
        .and old
        .or(old--)
    end)
  end
  test: (model) => do
    model.put_by(selected\test: (old) => do
      (old == 0)
        .and old
        .or(old--)
    end)
  end
}

select\down: .defcase {
  suite: (model) => do
    len = suites\all.len
    model.put_by(selected\suite: (old) => do
      (old == (len - 1))
        .and old
        .or(old++)
    end)
  end
  test: (model) => do
    (ok key) = model.test\suites.?.at(model.selected\suite)
    (has_selected, selected ) = ok.then () => model.test\suites.at(key)
    len = has_selected .then () => selected.suite\behaviors.len

    model.put_by(selected\test: (old) => do
      (old == (len - 1))
        .and old
        .or(old++)
    end)
  end
}

handle\keydown: .defcase {
  r: (ev model) => do
    queue_tests.()
    model.app\reset
  end
  k: (ev model) => do
    model.focus.select\up(model)
  end
  j: (ev model) => do
    model.focus.select\down(model)
  end
  l: (ev model) => model.put(focus: test:)
  h: (ev model) => model.put(focus: suite:)
  # For some reason, space: isn't working properly here.
  (' '.to\m) (ev model) => do
    (has_suite, suite, has_bhv, bhv) = model.app\get_selected

    (has_suite & has_bhv)
      .then(() => do
        model
          .put_via_by(
            test\suites:
            (suite.suite\name)
            suite\behaviors:
            bhv
            behavior\show:
            x => x!)
      end)
      .or model
  end
  Messages.t
  (ev model) => do
    'Unhandled event $\n'.sprintf(ev).eprintln
    model
  end
}

handle\keyup: .defcase {
  Messages.t
  (ev model) => model
}

handle\key: .defcase {
  true: (msg ev model) => msg.handle\keydown(ev model)
  false: (msg ev model) => msg.handle\keyup(ev model)
}

handle\type: .defcase {
  tick:  (ev model) => do
    # Tick time
    model.put_via_by(time: t => t++)
  end
  mouse: (ev model) => do
    model
  end
  key:   (ev model) => do
    keymsg = ev.at 0 .unwrap
    down = ev.at 2 .unwrap
    down.handle\key(keymsg ev model)
  end
  suite: (ev model) => do
    suite = ev .at 0 .unwrap
    model.app\push_suite(suite)
  end
  behavior: (ev model) => do
    behavior = ev .at 0 .unwrap
    model.app\push_behavior(behavior)
  end
  resolve: (ev model) => do
    model.app\resolve_behavior(ev*)
  end
}

spinner = "⣾⣾⣽⣽⣻⣻⢿⢿⡿⡿⣟⣟⣯⣯⣷⣷".collect []

App = test\app:.defclass(
  test\suites: test\tests: time: selected\suite: selected\test: focus:
  default:
  {
    app\controller: (type ev*) => do
      type.handle\type(ev self)
    end
    app\reset: () => do
      self
        .put(test\suites: {})
        .put(test\tests: {})
    end
    app\push_suite: (suite) => do
      self
        .put_via(test\suites:, suite.suite\name, suite)
    end
    app\push_behavior: (behavior) => do
      suite = behavior.behavior\path.at 0 .unwrap
      bhv = behavior.behavior\path.at 1 .unwrap

      self
        .put_via(test\suites: suite suite\behaviors: bhv behavior)
    end
    app\resolve_behavior: (outcome path meta) => do
      suite = path.at 0 .unwrap
      bhv = path.at 1 .unwrap

      self
        .put_via_by(
          test\suites:
          suite
          suite\behaviors:
          bhv
          behavior\assertions:
          (xs) => xs.cons(Assertion.make(meta outcome)))
    end
    app\get_selected: () => do
      app = self

      (ok, selected_key) = app.test\suites.?.at(app.selected\suite)
      (has_selected, selected) = ok.then () => app.test\suites.at(selected_key)

      tests = ok.then () => selected.suite\behaviors

      (has_selected_test, selected_test) = ok.then () => do
        tests.?.at(app.selected\test)
      end

      (has_selected.ok, selected, has_selected_test.ok, selected_test)
    end
    app\view: () => do
      app = self

      (has_selected, selected, has_selected_test, selected_test) = app.app\get_selected

      [
        [
          box:
          {
            h\g: 1
            w\g: 1
            layout: horizontal:
            bg: Colors.bg
          }
          [
            [
              box:
              {
                p\x: 9
                p\y: 21
                h\g: 1
                w\r: 50
                border: { w: 1 fg: (app.focus == suite:).and(Colors.fg\hl).or(Colors.bg\hl)}
                bg: Colors.bg
              }
              self.test\suites.map (suite, name) => do
                assertions = suite
                  .suite\behaviors
                  .join(
                    []
                    Streams.map (b => b.behavior\assertions.or []))

                pass_behaviors = assertions
                  .filter b => b.assertion\outcome == true:

                fail_behaviors = assertions
                  .filter b => b.assertion\outcome == false:

                waiting = suites\all .at name .unwrap .is\closed.!

                spinner_char = (waiting)
                  .then(() => spinner.at(app.time % spinner.len).unwrap)
                  .or " "

                color = (selected == suite).and(Colors.r).or(Colors.fg)

                [
                  box:
                  {
                    layout: horizontal:
                    w\g: 1
                    bg: Colors.bg
                  }
                  [
                    [
                      text:
                      {
                        p\x: 9
                        w\g: 1
                        fg: color
                        size: 32
                        content: "$ $".sprintf(spinner_char, name)
                      }
                    ]
                    [
                      text:
                      {
                        p\x: 9
                        fg: Colors.g
                        size: 32
                        content: "✔ $".sprintf(pass_behaviors.len)
                      }
                    ]
                    [
                      text:
                      {
                        p\x: 9
                        fg: Colors.r
                        size: 32
                        content: "✘ $".sprintf(fail_behaviors.len)
                      }
                    ]
                  ]
                ]
              end
            ]
            [
              box:
              {
                p\x: 9
                p\y: 21
                h\g: 1
                w\g: 1
                border: { w: 1 fg: (app.focus == test:).and(Colors.fg\hl).or(Colors.bg\hl)}
                bg: Colors.bg
              }
              has_selected
                .then(() => do
                  selected
                    .suite\behaviors
                    .map((bhv, k) => do
                      is_selected = (k == selected_test)
                      color = is_selected.and(Colors.r).or(Colors.fg)
                      some_err = bhv
                        .behavior\assertions
                        .any (a => a.assertion\outcome!)

                      (bhv.behavior\show | some_err)
                        .then(() => do
                          [
                            box:
                            {
                              layout: vertical:
                              bg: Colors.bg
                              fg: Colors.fg
                            }
                            [
                              [
                                text:
                                {
                                  p\x: 9
                                  size: 32
                                  fg: color
                                  content: bhv.behavior\path.join("" Streams.interpose "should" |> Streams.interpose " ")
                                }
                              ]
                              bhv
                                .behavior\assertions
                                .then(() => do
                                  bhv
                                    .behavior\assertions
                                    .map(atn => do
                                      [
                                        text:
                                        {
                                          p\x: 18
                                          size: 32
                                          fg: color
                                          content: '$ $ $'.sprintf(
                                            atn.assertion\meta.lhs
                                            atn.assertion\meta.cmp
                                            atn.assertion\meta.rhs
                                          )
                                        }
                                      ]
                                    end)
                                end)
                                .or([])
                                .*
                            ]
                          ]
                        end)
                        .else(() => do
                          [
                            text:
                            {
                              p\x: 9
                              size: 32
                              fg: color
                              content: bhv.behavior\path.join("" Streams.interpose "should" |> Streams.interpose " ")
                            }
                          ]
                        end)
                    end)
                end)
                .or([[text: { size: 32 content: "none" }]])
            ]
          ]
        ]
      ]
    end
  })

model = App.make({} {} 0 0 0 suite:)

queue_tests.()

events
  .pipe(
    app,
    Streams.take_until((e, key) => do
      (e == key:) & ((key == escape:) | (key == q:))
    end)
    |> Streams.reduce(model (model, args*) => model.app\controller (args*))
    |> Streams.map(app => app.app\view)
  )

app.close
events.close
